#'Count tag assignments to taxonomic groups and calculate final scores.
#'
#'@param count_mat count matrix generated by `CandidateSearchDatabase` by
#'  searching tags against organism database.
#'@param overlap_mat matrix of overlap coefficients between all organisms
#'  represented in the columns of count_mat.
#'@param organism_df dataframe containing the column taxonomic_groups which
#'  gives the clusters for each organism in overlap_mat and count_mat.
#'@param min_group_hits minimum number of tags required for a taxonomic group to
#'  be scored, default 2.
#'@param export_matrix_path If not NULL (default) then the reduced matrix will
#'  be written to a csv using the export_matrix_path
#'@inheritParams assign_tags
#'
#'@return returns a dataframe of final scores.
#'@importFrom assertthat assert_that
#'@importFrom dplyr select mutate filter left_join inner_join
#'@importFrom MASS ginv
#'@importFrom nnls nnls
#'@importFrom magrittr %>%
#'@importFrom rlang .data
#'@export
calculate_taxonomic_scores <- function(count_mat,
                                       overlap_mat,
                                       organism_df,
                                       min_group_hits = 2,
                                       Pthrsh = 0.4,
                                       export_matrix_path = NULL) {

  #enforce conformable matrices with assert
  assertthat::assert_that(ncol(count_mat) == nrow(overlap_mat),
                          msg = "Score matrix and overlap matrix do not have matching dimensions.")

  #enforce name consistency
  assertthat::assert_that(all(colnames(count_mat) == organism_df$kegg_id),
                          msg = "Column names of the count matrix should match kegg_id column of organism_df")


  print("Calculating taxonomic group scores...")

  #calculate cosine similarity
  similarity_mat <- count_mat %*% overlap_mat

  #assigned_ind has length = # of tag -> organism mappings
  #the value is the position of the organism the tag is assigned to
  assigned_ind <- assign_tags(similarity_mat,
                              pepcount = rowSums(count_mat),
                              Pthrsh = Pthrsh)

  #tabulate hits per organism
  #slice selects the row # defined in the value of assigned_ind
  #so you end up having one row for each tag
  #if an organism has multiple tags assigned to it it will be duplicated to have multiple rows
  #so if you count by kegg_id you get number of tags per organism
  tabulated_organism_hits <- organism_df %>%
    dplyr::select(.data$kegg_id) %>%
    dplyr::slice(assigned_ind) %>%
    dplyr::count(.data$kegg_id) %>%
    dplyr::rename("organism_hits" = "n")

  #tabulate hits per group
  #see above ^^
  # if you count by taxonomic_group you will get number of tags per taxonomic group
  tabulated_group_hits <- organism_df %>%
    dplyr::select(.data$taxonomic_group) %>%
    dplyr::slice(assigned_ind) %>%
    dplyr::count(.data$taxonomic_group) %>%
    dplyr::rename("group_hits" = "n") %>%
    dplyr::filter(.data$group_hits >= min_group_hits)

  print(paste0(nrow(tabulated_group_hits),
               " taxonomic groups passed the minimum hits threshold of ",
               min_group_hits ))

  #modify taxonomic scores based on overlap between groups
  if (nrow(tabulated_group_hits) > 1) {
    #reduce overlap matrix to relevant groups
    group_names <- organism_df$taxonomic_group
    group_select <-
      group_names %in% tabulated_group_hits$taxonomic_group
    reduced_matrix <- reduce_overlap_matrix(overlap_mat[group_select, group_select],
                                            grouping = group_names[group_select])

    #writing reduced matrix to file if export_reduced_matrix is not NA
    if(!is.null(export_matrix_path))
    {
      print(reduced_matrix)
      reduced_matrix %>%
        as.data.frame() %>%
        tibble::rownames_to_column() %>%
        readr::write_csv(file = export_matrix_path)

    }

    #create new scores based on reduced matrix
    tabulated_group_hits <- tabulated_group_hits %>%
      dplyr::mutate(
        orgscores = as.vector(MASS::ginv(reduced_matrix) %*% .data$group_hits),
        pos_scores = nnls::nnls(reduced_matrix, .data$group_hits)$x
      )
  }



  #create final dataframe as an extension of organism_df
  score_df <- organism_df %>%
    dplyr::left_join(tabulated_organism_hits,
                     by = "kegg_id") %>%
    dplyr::mutate(organism_hits = replace(.data$organism_hits,
                                          is.na(.data$organism_hits), 0.)) %>%
    dplyr::inner_join(tabulated_group_hits,
                      by = "taxonomic_group")

  return(score_df)
}

#'Count tag assignments to taxonomic groups and calculate final robust scores.
#'
#'\code{calculate_robust_taxonomic_scores} will provide a secondary scoring step
#'on top of \code{calculated_taxonomic_scores} which will attempt to set low count
#'identifications to 0.
#'
#'@param count_mat count matrix generated by CandidateSearchDatabase by searching
#'  tags against organism database.
#'@param overlap_mat matrix of overlap coefficients between all organisms represented
#'  in the columns of count_mat.
#'@param organism_df dataframe containing the column taxonomic_groups which gives
#'  the clusters for each organism in overlap_mat and count_mat.
#'@param Pthrsh minimum threshold for keeping the tag assignment, default 0.4.
#'@param min_group_hits minimum tag assignment threshold for keeping a taxonomic group, default 2.
#'@param rthrsh threshold for max score to trigger a robust analysis.
#'
#'@return returns a dataframe of final scores.
#'@importFrom assertthat assert_that
#'@importFrom dplyr select distinct summarise filter mutate left_join
#'@importFrom magrittr %>%
#'@importFrom rlang .data
#'@importFrom stats quantile median
#'@export
calculate_robust_taxonomic_scores <- function(count_mat,
                                              overlap_mat,
                                              organism_df,
                                              Pthrsh = 0.4,
                                              min_group_hits = 2,
                                              rthrsh = 100) {

  #run first pass to get taxonomic scores
  score_df <- calculate_taxonomic_scores(
    count_mat,
    overlap_mat,
    organism_df,
    Pthrsh = Pthrsh,
    min_group_hits = min_group_hits
  )

  #perform robust analysis if necessary
  summary_stats <- score_df %>%
    dplyr::select(.data$taxonomic_group, .data$pos_scores) %>%
    dplyr::distinct() %>%
    dplyr::summarise(
      max = max(.data$pos_scores),
      median = stats::median(.data$pos_scores)
    )
  if (summary_stats$max >= rthrsh * summary_stats$median) {
    #get positions of peptides which do not map to top performers
    filtered_df <- score_df %>%
      dplyr::filter(.data$pos_scores >= rthrsh * summary_stats$median)

    column_select <- colnames(count_mat) %in% filtered_df$kegg_id
    row_select <- rowSums(count_mat[, column_select]) == 0

    #rescore other organisms
    sub_score_df <- calculate_taxonomic_scores(count_mat[row_select, ],
                                               overlap_mat,
                                               organism_df,
                                               Pthrsh = Pthrsh,
                                               min_group_hits = min_group_hits) %>%
      dplyr::select(.data$taxonomic_group, .data$orgscores, .data$pos_scores) %>%
      dplyr::distinct()

    #update score_df if enough new taxonomic groups present
    if (nrow(sub_score_df) >= sqrt(rthrsh)) {
      qvals <- stats::quantile(sub_score_df$pos_scores, probs = c(0.25, 0.75))
      critval <- qvals[2] + 1.5 * (qvals[2] - qvals[1])

      sub_score_df <- sub_score_df %>%
        dplyr::mutate(
          orgscores = replace(.data$orgscores, .data$pos_scores <= critval, 0),
          pos_scores = replace(.data$pos_scores, .data$pos_scores <= critval, 0)
        )

      update_df <- score_df %>%
        dplyr::select(.data$taxonomic_group) %>%
        dplyr::left_join(sub_score_df,
                         by = "taxonomic_group")

      row_select <- !is.na(update_df$pos_scores)
      score_df[row_select, ]$orgscores <-
        update_df[row_select, ]$orgscores
      score_df[row_select, ]$pos_scores <-
        update_df[row_select, ]$pos_scores
      score_df <- score_df[score_df$pos_scores > 0, ]
    }
  }

  return(score_df)
}
